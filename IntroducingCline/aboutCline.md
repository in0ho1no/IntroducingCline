---
html:
  embed_local_images: true
  embed_svg: true
  offline: true
  toc: true
export_on_save:
  html: true
---

# Clineの仕組みと効果的な活用方法

本ファイルは、in0ho1noがClaude Sonnet 4に依頼しながら作成したファイルです。  
Clineをこれから学習するにあたっての前提知識を得る目的でざっくりとした概要を示すものであり、より正確な情報や最新情報は必ず自身で確認してください。

## Clineとは

ClineはVSCodeで動作するAI開発アシスタント拡張機能である。複数のAIプロバイダーに対応しており、自然言語による指示からコードの読み取り、編集、ファイル作成、コマンド実行などを自動化できる。

## 基本的な動作原理

### 初期設定

- VSCodeの拡張機能としてインストール
- 対応するAIプロバイダーのAPIキーを設定
- 使用するAIモデルを選択

### 起動と初期化

- Clineを起動すると、VSCodeのサイドパネルにチャット画面が表示される
- 現在開いているワークスペースを認識する

## 対応AIプロバイダー

Clineは以下の多様なAIプロバイダーに対応している：

### 主要クラウドプロバイダー

- Anthropic: Claude 3.5 Sonnet, Claude 4等
- OpenAI: GPT-4, GPT-4 Turbo, GPT-3.5等
- Google: Gemini 1.5 Pro, Gemini 2.0 Flash, Gemini 2.5 Pro等
- AWS Bedrock: Amazon経由でのモデルアクセス
- Azure OpenAI: Microsoft Azure経由でのOpenAIモデル
- GCP Vertex AI: Google Cloud経由でのモデルアクセス

### 統合プラットフォーム

- OpenRouter: 複数のAIモデルへの統一アクセス
- Cerebras: 高速推論プラットフォーム

### ローカル実行

- LM Studio: ローカルでのLLM実行
- Ollama: ローカルモデル管理・実行プラットフォーム
- OpenAI互換API: カスタムAPIエンドポイント

:::info
ローカル実行とは、LLM（大規模言語モデル）をインターネット経由ではなく、自分のPC上で直接動作させる方法である。機密性の高いコードでも外部に送信せずに安全に利用できる。
:::

### プロバイダー選択の考慮事項

- コスト: DeepSeek（低コスト）vs GPT-4（高性能・高コスト）
- 性能: コーディング特化モデル vs 汎用モデル
- レスポンス速度: クラウド vs ローカル実行
- プライバシー: クラウド送信 vs ローカル処理

## コンテキストの仕組み

### 「コンテキスト」の2つの意味

#### 探索範囲としてのコンテキスト

- Clineはワークスペース全体のフォルダ構造を把握する
- ファイル名、フォルダ構造、プロジェクト構成を「地図」として認識する
- 「どこに何があるか」を知っている状態

```text
my-project/
├── src/
│   ├── components/
│   ├── pages/
│   └── utils/
├── package.json
└── README.md
```

#### 処理用データとしてのコンテキスト

- Clineは処理に必要なデータを動的に構築する

```text
ユーザー: "ログイン機能を追加して"

↓ Clineの思考プロセス

1. ワークスペース構造から関連ファイルを特定
   - "auth" "login" "user" 関連のファイル名を検索
   - src/components/LoginForm.tsx (存在する場合)
   - src/utils/auth.ts (存在する場合)

2. 必要なファイルの中身を実際に読み取り
   - package.jsonの依存関係
   - 既存の認証関連コード
   - プロジェクトの構成パターン

3. これらを組み合わせて「実際の処理用コンテキスト」を構築
```

#### コンテキストの区別

図書館を例に、コンテキストの区別を示す。

```text
[ワークスペース全体] = 図書館全体
[処理用コンテキスト] = 机の上に広げた必要な本

図書館全体を把握しているが、
実際に読んでいるのは机の上の本だけ
```

## トークン効率性の仕組み

### ありがちな誤解

ありがちな誤解として、ClineからLLMに全データが送信される思い違いがある。

```text
ワークスペース全体 → 全ファイル読み込み → LLMに送信
├── 数千〜数万のファイル
├── 数百万行のコード
└── APIトークン制限を即座に突破
```

### 実際のClineの動作

実際には、Clineが必要な情報を事前に選定し、その情報のみをLLMに送信する。

```text
指示分析 → 関連ファイル特定 → 必要分のみ読み込み → LLMに送信
├── 通常5-20ファイル程度
├── 数百〜数千行のコード
└── トークン制限内で動作
```

### 具体的なトークン消費例

1行あたりザックリ30トークンとして概算する。  
以下のようなプロジェクト規模において全ファイルを読み込んだ場合、想定トークンは3,000,000を超え、LLMのトークン制限を突破してしまう。

- 総ファイル数: 2,000+
- 総行数: 100,000+

実際のClineではプロジェクトを全て読み込むわけではないため、想定トークンは15,000程度まで抑えられる。  

- 選択されたファイル数: 8
- 読み込まれた行数: 500

:::info
トークンの制限はモデルにもよる。  
OpenAIのGPT3.5 Turboでは16,000 / GPT-4oでは128,000など。  
入力と出力の合計が制限に収まる必要がある。  
:::

:::info
トークンの扱いは自然言語、プログラミング言語の違いやLLM(トークナイザ)によっても異なる。  
実際に扱う際は、環境に応じて試算・実測するのを推奨する。  
:::

## 潜在的な問題：取り違え・取り逃し

ClineがLLMにデータを渡すにあたって必要な情報を選定しているため、ファイル名・フォルダ構造によっては取り逃しが発生しうる。以下に具体例を示す。

### 推定に失敗しやすいケース

1. 意味のない命名: `script.py`, `temp.py`, `utils.py`, `test123.py`, `old_stuff.py`
1. プロジェクト名と内容の乖離: `chat_app`プロジェクト内の`image_processor.py`
1. レガシーコードの命名規則: `backup_`, `old_`, `deprecated_`で始まるが現役

### 問題が起こりやすいケース

#### ファイル名とコンテンツの不一致

```text
ocr_project/
├── fizzbuzz.py          # 実は重要なOCR前処理コード
├── temp_script.py       # 実はメインのOCR実装
├── legacy_utils.py      # 実は現在も使用中の重要関数
└── new_feature.py       # 実は古いコード
```

#### 従来プロジェクトでよくある命名

```text
web_app/
├── script.py           # メインのビジネスロジック
├── utils.py            # 実はDBアクセス層
├── temp.py             # プロダクション稼働中のコード
├── backup_old.py       # 実は最新の実装
└── test123.py          # 実は重要な外部API連携
```

## 効果的な使い方のコツ

### 明確な指示

Clineへの指示を明確にする。  

- 悪い例: "これを直して"
- 良い例: "src/components/Header.tsxのレスポンシブ対応を追加してください"

### 必要な情報の事前提供

プロジェクトに関する情報を事前に提供する。

:::user
現在のプロジェクトはNext.js 14とTailwind CSSを使用している。  
ユーザー管理機能を追加したい。
:::

### 段階的な作業

大きな機能は小さな単位に分けて指示する。

## チーム運用のための設定ファイル化

### 背景と目的

従来のプロジェクトでは、ファイル名と実際の機能が一致しないことがよくある。例えば、`temp.py`という名前でありながら実際は本番環境で動作する重要なコードであったり、`old_backup.py`という名前でありながら最新の実装が含まれていたりする。

Clineはファイル名から機能を推測するため、このような状況でClineを使用すると、重要なファイルを見落としたり、古いファイルを誤って選択したりする可能性がある。

この問題を解決するため、Clineが自動的に読み込む `.clinerules`ファイルを利用する。  
これにより、チーム全体が同じ前提知識でClineを効果的に活用できるようになる。

### `.clinerules`ファイルの仕組み

`.clinerules`は、Clineが自動的に参照する特別な設定ファイルである。プロジェクトのルートフォルダに配置することで、Clineがタスクを実行する際に常にこのファイルの内容を考慮するようになる。

### 設定ファイルの作成

例として、OCRソフト開発プロジェクトを題材にした設定ファイルを示す。

#### `.clinerules`ファイルの作成

プロジェクトのルートフォルダに `.clinerules` というファイルを作成する。

#### `.clinerules`の記載例

具体的に`.clinerules`へ記載する内容を以下に示す。  

```markdown
# OCRソフト開発プロジェクト - Cline用プロジェクトルール

## プロジェクト概要

このプロジェクトは、画像から文字を認識するOCRソフトウェアを開発している。
Python 3.9以上を使用し、OpenCVとTesseractをベースとしたシステムである。

## 重要：ファイル名と実際の機能の対応表

### メインシステムファイル（名前に惑わされないこと）

- `fizzbuzz.py` → OCR前処理エンジン（FizzBuzzゲームではない！）
- `temp_script.py` → OCR実行の中核ロジック（一時ファイルではない！）
- `legacy_utils.py` → 現在使用中のユーティリティ関数（レガシーではない！）
- `backup_old.py` → 最新の認証処理実装（古いバックアップではない！）
- `test123.py` → 外部API連携処理（テストファイルではない！）

### データベース関連

- `db_handler.py` → メインのデータベース接続処理（これを使用すること）
- `database.py` → 【使用禁止】古いDB接続コード

### 設定ファイル

- `config/settings.py` → 実行時設定ファイル
- `config/api_keys.py` → API認証情報（環境変数から読み込み）

## 修正・実装時の必須ルール

1. 認証機能の修正時: 必ず `backup_old.py` を編集すること
2. OCR処理の修正時: `fizzbuzz.py`（前処理）と `temp_script.py`（メイン処理）を確認
3. データベース処理: `db_handler.py` のみを使用し、`database.py` は絶対に使用しない
4. API連携: `test123.py` の既存実装を参考にする

## プロジェクト固有の命名規則

- OCR関連の関数: 全て `ocr_` プレフィックスを付ける
- データベースクエリ: `queries/` フォルダ内のSQLファイルを使用
- API エンドポイント: `/api/v2/` パターンに従う
- 新規ファイル作成時: 必ず意味のある名前を付ける（temp, test等は避ける）

## 無視すべきファイル・フォルダ

- `new_feature.py` - 古い実装、使用禁止
- `old_code/` フォルダ全体 - アーカイブ用、参照禁止
- `*.bak` ファイル - バックアップファイル、編集禁止

## エラー処理の標準

- 全ての例外は `utils/error_handler.py` のカスタム例外を使用
- ログは `logging` モジュールを使用（print文は使用しない）

## テストに関する規則

- ユニットテストは `tests/` フォルダに配置
- テストファイル名は `test_*.py` の形式
- pytestフレームワークを使用

## 追加の注意事項

- このプロジェクトでは歴史的経緯により、多くのファイル名が実際の機能と一致しない
- 新規開発時は必ず既存のパターンを確認してから実装する
- 不明な点がある場合は、まず関連ファイルの内容を確認する

```

### `.clinerules`の効果的な活用

#### 自動読み込みの利点

`.clinerules`ファイルは、Clineがタスクを開始する際に自動的に読み込まれるため：

1. 明示的な指示が不要: 「プロジェクト説明を読んで」などの前置きが不要
1. 一貫性の確保: チーム全員が同じルールに従って作業
1. ミスの防止: ファイル名の取り違えを防ぐ

#### 実際の使用例

`.clinerules`を設定してあればシンプルな指示にできる。

:::user
認証機能にリフレッシュトークンを追加して
:::

:::cline
1.`.clinerules`を自動参照  
2.backup_old.py が認証処理ファイルだと認識  
3.対象となるファイルを編集  
:::

### チーム運用のベストプラクティス

#### 定期的な更新

- 週次: 新規ファイルや変更されたファイルの情報を追加
- 月次: 全体の見直しと不要な情報の削除

#### バージョン管理

- `.clinerules`もプロジェクトのファイルと同様に構成管理する

#### レビュープロセス

- Pull Request時に`.clinerules`の更新も確認
- ファイル名変更時は必ず`.clinerules`も同時に更新

### 高度な設定例

`.clinerules`の追加の設定例を以下に示しておく。

```markdown
## AIへの指示
- コードレビュー時は必ずPEP 8に準拠しているか確認
- 新規関数には必ずdocstringを追加
- 型ヒントを可能な限り使用

## パフォーマンス最適化ルール
- データベースクエリは必ずインデックスを確認
- ループ内でのDB接続は避ける
- 大量データ処理時はジェネレータを使用

## セキュリティルール
- ユーザー入力は必ずサニタイズ
- SQLクエリはプレースホルダを使用
- 機密情報は環境変数から読み込み
```

## トラブルシューティング

### Clineが期待通りに動作しない場合

1. ワークスペースの再読み込み: VSCodeでワークスペースを一度閉じて再開
1. APIキーの確認: 有効期限や権限設定をチェック
1. モデル選択の見直し: タスクに適したモデルを選択

### パフォーマンスが遅い場合

1. 不要なファイルの除外: `.gitignore`や`.clinerules`での除外設定
1. モデルの変更: より高速なモデルへの切り替え
1. 指示の明確化: 曖昧な指示を具体的に修正

### `.clinerules`が効かない場合

1. ファイルの配置を確認: プロジェクトルートに配置されているか
1. ファイル名を確認: 正確に`.clinerules`（拡張子なし）か
1. 文字コードを確認: UTF-8で保存されているか

### ルールの優先順位

Clineは以下の優先順位で動作する

1. ユーザーの明示的な指示
2. `.clinerules`の内容
3. 一般的なベストプラクティス

## 制限事項

1. APIトークン制限: 一度に処理できるコンテキストサイズに上限
1. ファイル数制限: 巨大なプロジェクトでは全体を把握しきれない場合
1. リアルタイム制約: ファイル変更の同期にわずかな遅延
1. 推定精度: ファイル名と内容の不一致による取り違え・取り逃しの可能性

## セキュリティとコンプライアンス

### 機密情報の取り扱い

- APIキーや認証情報が含まれるファイルは事前に除外しておく
- 本番環境のデータベース接続情報は共有しない
- 社内固有のビジネスロジックの取り扱いに注意する

### コード品質の確保

- 生成されたコードは必ず人間によるレビューを実施
- セキュリティホールの有無を確認
- 既存のコーディング規約との整合性をチェック

## 設計思想の理解

ここまでに紹介した仕組みにより以下が実現されている。

### スケーラビリティ

- 企業レベルの大規模プロジェクトでも動作
- 単一のリポジトリに情報がまとめられた構成でも効率的に処理

### コスト効率

- 無駄なAPI呼び出しを削減
- 必要な情報のみを精密に抽出

### 応答速度

- 不要なファイル処理をスキップ
- より高速な応答時間

Clineは必要最小限のデータを動的に選択して処理するため、大規模プロジェクトでも効率的に動作する。  
この理解により、より効果的にClineを活用できるであろう。
